## 느낀점
> 
- X

## 흐름

1. **그래프 구성**: 양방향 인접 리스트로 연결 정보 저장
2. **DFS 탐색**: 1번 노드에서 시작, 스택으로 연결된 모든 노드 방문
3. **카운팅**: 새로 방문하는 노드마다 result 증가

## 코드
```python
"""
7
6
1 2
2 3
1 5
5 2
5 6
4 7
"""

import sys
from collections import defaultdict
input = sys.stdin.readline

N = int(input())
edgeCount = int(input())
edges = defaultdict(list)
for _ in range(edgeCount):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)

stack = [1]
visited = [False]*(N+1)
visited[1] = True
result = 0
while(stack):
    cur = stack.pop()
    for node in edges[cur]:
        if(not visited[node]):
            visited[node] = True
            stack.append(node)
            result += 1
print(result)

```

## 질문 & 실수 정리

**질문했던 내용 (새로 배운 것)**

| 질문 | 답변 |
|------|------|
| visited를 pop할 때 체크하면 안 돼? | 중복 삽입 발생. 같은 노드가 큐/스택에 여러 번 들어가서 시간 낭비 + 카운팅 오류 가능 |

**실수했던 부분**

(없음)

## AI 코드 리뷰

**개선할 점**

1. **변수명 개선**: `edgeCount` → `M` (관례), `edges` → `graph` (그래프임을 명확히)

2. **defaultdict 불필요**: 노드 번호가 1~N으로 고정이므로 일반 리스트가 더 직관적

**수정된 코드**

```python
import sys
input = sys.stdin.readline

N = int(input())
M = int(input())

graph = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

stack = [1]
visited = [False] * (N + 1)
visited[1] = True
result = 0

while(stack):
    cur = stack.pop()
    for(node in graph[cur]):
        if(not visited[node]):
            visited[node] = True
            stack.append(node)
            result += 1

print(result)
```