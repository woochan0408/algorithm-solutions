## 느낀점
>
- dp 2번째 차원을 너무 어렵게 생각함 
(전전단계의 계단도 계산해야 된다고 생각)
- 유연하게 생각하자.
- 백준 포도주시식(2156) 보다 쉽고 아이디어도 똑같은데 틀린게 참 아쉽다.

## 흐름

1. **DP 상태 정의**: `dp[i][j]` = i번째 계단을 밟았을 때 최댓값
   - `j=0`: 직전(i-1) 계단 안 밟음
   - `j=1`: 직전(i-1) 계단도 밟음
2. **점화식**:
   - `dp[i][0]` = i-2에서 점프해서 옴 → `max(dp[i-2]) + stairs[i]`
   - `dp[i][1]` = i-1에서 한 칸 올라옴 (단, i-1은 점프로 왔어야 함) → `dp[i-1][0] + stairs[i]`
3. **예외 처리**: N=1, N=2인 경우 별도 처리

## 코드

```python
import sys
input = sys.stdin.readline

N = int(input())
stairs = []
for _ in range(N):
    stairs.append(int(input()))

if(N == 1):
    print(stairs[0])
elif(N == 2):
    print(stairs[0] + stairs[1])
else:
    dp = [[0, 0] for _ in range (N)]
    dp[0][0] = stairs[0]
    dp[1][0] = stairs[1]
    dp[1][1] = stairs[0] + stairs[1]
    
    for i in range(2, N):
        dp[i][0] = max(dp[i-2]) + stairs[i]
        dp[i][1] = dp[i-1][0] + stairs[i]
    print(max(dp[N-1]))
```

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 전전 계단 밟았는지 여부를 어떻게 아나? | 상태 전이 규칙으로 해결. `dp[i][1]`은 반드시 `dp[i-1][0]`에서만 올 수 있어서 3연속이 자동으로 방지됨 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|-----------|
| 상태를 `[0,1,2,3]` 4개로 복잡하게 정의 | "직전 밟았는지" 여부 하나(`[0,1]`)로 충분 |
| `dp[2]` 초기화 후 `range(2, N)`에서 덮어씀 | 초기화는 `dp[0]`, `dp[1]`까지만, 반복은 `range(2, N)` |

## AI 코드 리뷰

### 개선할 점

1. **입력 리스트 컴프리헨션**: 반복문 대신 한 줄로 작성 가능

2. **`dp[0][1]` 의미 명확화**: 사용되지 않지만, 주석이나 초기값으로 "불가능한 상태"임을 표현하면 더 명확

3. **예외 처리 통합 가능**: N=1, N=2도 일반 로직에 포함시킬 수 있음 (초기화를 조건부로)

## 수정된 코드

```python
import sys
input = sys.stdin.readline

N = int(input())
stairs = [int(input()) for _ in range(N)]

if(N == 1):
    print(stairs[0])
elif(N == 2):
    print(stairs[0] + stairs[1])
else:
    # dp[i][0]: i번째 밟음, 직전 안 밟음
    # dp[i][1]: i번째 밟음, 직전도 밟음
    dp = [[0, 0] for _ in range(N)]
    dp[0][0] = stairs[0]
    dp[1][0] = stairs[1]
    dp[1][1] = stairs[0] + stairs[1]

    for i in range(2, N):
        dp[i][0] = max(dp[i-2]) + stairs[i]
        dp[i][1] = dp[i-1][0] + stairs[i]

    print(max(dp[N-1]))
```