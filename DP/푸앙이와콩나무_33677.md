## 느낀점
>
- 삽질하면서 배운게 많은 문제다.
(힌트를 많이 받았으니 다시 한번 더 풀어보기)
- 당연히 백트래킹 문제라고 생각하고 시작했다.
- 재귀는 기본적으로 DFS 성질을 띄고 있음
- 이 문제는 최솟값이 발생한 레벨에 대해서만 전부 탐색해야 함
(즉 백트래킹(DFS) 로는 시간초과가 일어남)
- 코드를 BFS + 가지치기로 변경 -> 아슬아슬하게 통과
- 코드리뷰에선 힙큐를 사용했고 훨씬 간결하고 빨랐다.
---

## 실패한 흐름 (백트래킹)

### 접근 방식
1. 백트래킹으로 모든 경로 탐색
2. 목표 높이 도달 시 최소 일수, 최소 물 갱신
3. 가지치기: `curHeight > targetHeight` 또는 `curDay >= minDay`면 종료

### 실패 원인
- **중복 탐색**: 같은 높이에 여러 경로로 도달하면 모두 탐색
- **재귀 깊이 초과**: `+1`만 반복하면 N=1,000,000일 때 재귀 깊이 100만
- **1 제곱 무한루프**: `1 ** 2 = 1`로 무한 재귀
- **호출 순서 문제**: `+1`을 먼저 호출하면 느린 경로부터 탐색

### 실패한 코드

```python
import sys
sys.setrecursionlimit(10**6)

minDay = float('inf')
minWater = float('inf')

def back(curWater, curDay, curHeight):
    global minDay
    global minWater
    if curHeight == targetHeight:
        if minDay > curDay or (minDay == curDay and minWater > curWater):
            minDay = curDay
            minWater = curWater
        return
    if curHeight > targetHeight:
        return
    if minDay < curDay:
        return
    
    if curHeight > 1:
        back(curWater+5, curDay+1, curHeight**2)
    if curHeight != 0:
        back(curWater+3, curDay+1, curHeight*3)
    back(curWater+1, curDay+1, curHeight+1)

targetHeight = int(input())
if targetHeight == 0:
    print("0 0")
else:
    back(0, 0, 0)
    print("%d %d" % (minDay, minWater))
```

---

## 성공한 흐름 (BFS)

### 접근 방식
1. BFS로 레벨(일수) 단위 탐색
2. `visited`를 `dict`로 관리: `{높이: (일수, 물)}`
3. 같은 높이에 더 좋은 경로로 이미 도달했으면 스킵
4. 목표 도달 시 같은 레벨까지 탐색 후 종료

### 코드

```python
from collections import deque

minDay = float('inf')
minWater = float('inf')
        
def bfs():
    global minDay
    global minWater
    
    dq = deque()
    visited = {}
    dq.appendleft((0, 0, 0))
    stopDay = float('inf')
    
    while dq:
        curDay, curWater, curHeight = dq.pop()
        
        if curDay > stopDay:
            continue
        
        if curHeight in visited:
            prevDay, prevWater = visited[curHeight]
            if prevDay < curDay or (prevDay == curDay and prevWater <= curWater):
                continue
        visited[curHeight] = (curDay, curWater)
        
        if curHeight == targetHeight:
            if minDay > curDay or (minDay == curDay and minWater > curWater):
                minDay = curDay
                minWater = curWater
                stopDay = curDay
            continue
            
        if curHeight > targetHeight:
            continue
            
        if curHeight > 1:
            dq.appendleft((curDay+1, curWater+5, curHeight**2))
        if curHeight != 0:
            dq.appendleft((curDay+1, curWater+3, curHeight*3))
        dq.appendleft((curDay+1, curWater+1, curHeight+1))
        
    
targetHeight = int(input())
if targetHeight == 0:
    print("0 0")
else:
    bfs()
    print("%d %d" % (minDay, minWater))
```

---

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 전역 변수 수정 시 global 선언만 하면 돼? | 함수 내에서 전역 변수를 **수정(할당)**하려면 `global` 필수. 읽기만 할 때는 불필요 |
| minDay 초기값 뭘로? int인데 float('inf') 써도 돼? | 파이썬은 `float('inf')`와 `int` 비교 가능. 또는 적당히 큰 값(100) 사용 |
| sys.setrecursionlimit 사용법? | `sys.setrecursionlimit(10**6)` — 단, 재귀 깊이 에러 시 종료 조건 먼저 점검 |
| BFS에서 최소 일수의 최소 물을 찾으려면 바로 stop 불가능 아닌가? | 방법 2가지: (1) 같은 레벨 끝까지 탐색 (2) 우선순위 큐로 `(일수, 물)` 정렬 |
| visited를 언제 체크해야 하나? | push할 때가 아니라 **pop할 때** 체크해야 같은 레벨 내 최적 경로 놓치지 않음 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|----------|
| `if curHeight > 0: return` | `if curHeight > targetHeight: return` |
| global 키워드 누락 | 함수 시작에 `global minDay, minWater` 추가 |
| 1 제곱 시 무한 재귀 | `if curHeight > 1:` 조건 추가 |
| `if minDay > curDay:` (같은 일수 무시) | `if minDay > curDay or (minDay == curDay and minWater > curWater):` |
| `+1` 연산 먼저 호출 (느린 경로 먼저) | 제곱 → ×3 → +1 순서로 변경 |
| `visited`를 `set`으로 사용 | `dict`로 변경하여 `{높이: (일수, 물)}` 저장 |
| `and not A or B` (괄호 누락) | `and (not A or B)` 명시적 괄호 |

---

## AI 코드 리뷰

### 개선할 점

1. **변수명 개선**: `dq` → `queue`, `curHeight` → `height`가 더 직관적

2. **global 제거**: 함수에서 결과를 return하는 방식이 더 깔끔

3. **우선순위 큐 활용**: `heapq`로 `(일수, 물, 높이)` 정렬하면 로직이 훨씬 단순해짐

4. **중복 조건 제거**: `stopDay`와 `minDay` 비교가 중복됨

---

## 더 나은 로직 (우선순위 큐)

### 흐름
- `heapq`는 튜플 기준 자동 정렬: (일수, 물, 높이)
- 첫 번째 요소(일수) 기준 최소힙, 같으면 두 번째(물) 기준
- 같은 높이에 처음 도달 = 무조건 (최소 일수, 최소 물)
- visited 체크만으로 충분, stopDay 로직 불필요

### 수정된 코드

```python
import heapq

def solve():
    targetHeight = int(input())
    if targetHeight == 0:
        print("0 0")
        return
    
    heap = [(0, 0, 0)]  # (일수, 물, 높이)
    visited = set()
    
    while heap:
        day, water, height = heapq.heappop(heap)
        
        if height in visited:
            continue
        visited.add(height)
        
        if height == targetHeight:
            print(day, water)
            return
        
        if height > targetHeight:
            continue
        
        heapq.heappush(heap, (day+1, water+1, height+1))
        if height != 0:
            heapq.heappush(heap, (day+1, water+3, height*3))
        if height > 1:
            heapq.heappush(heap, (day+1, water+5, height**2))

solve()
```