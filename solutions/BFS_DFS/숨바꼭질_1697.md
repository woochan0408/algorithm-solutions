# 숨바꼭질

## 느낀점
- 처음엔 뭔가 수학적 구현(with 그리디)로 될 것 같았는데 예외가 너무 많았다.
- 푸앙이와 콩나무(33677)와 비슷한 문제라 힌트 없이 풀 수 있었다. (푸앙아 고마워)
- 막상 이렇게 나오니까 어떤 자료구조 쓸 지 막막했다. 그리디도 많이 풀면서 감을 익히자

## 흐름
1. **역방향 BFS**: K(목표)에서 N(시작)으로 역탐색
2. **이동 옵션**: `n//2` (짝수일 때), `n-1`, `n+1`
3. **종료 조건**: 현재 위치가 N과 같으면 step 반환

## 코드
```python
from collections import deque
moveCount = 0
        
N, K = map(int, input().split())
dq = deque()
dq.appendleft((K, 0))
visited = set()
result = 0
while(dq):
    n, step = dq.pop()
    if(n == N):
        result = step
        break
    if(n in visited): continue
    visited.add(n)
    if(n%2 == 0):
        dq.appendleft((n//2, step+1))
    if(n > 0):
        dq.appendleft((n-1, step+1))
    dq.appendleft((n+1, step+1))
print(result)
```

## 실수 정리

### 실수했던 부분

|틀린 것|올바른 것|
|---|---|
|`if(n in visited): continue`만 있고 추가 로직 없음|`visited.add(n)`으로 방문 표시 필수|

## AI 코드 리뷰

### 개선할 점

1. **불필요한 변수 제거**: `moveCount`가 선언만 되고 사용되지 않음

2. **범위 제한 필요**: `n+1`이 무한정 커질 수 있음 → `0 <= n <= 100000` 범위 체크 권장

3. **정방향 탐색 권장**: K→N 역방향보다 N→K 정방향이 더 직관적

4. **BFS 관례**: `appendleft` + `pop` 대신 `append` + `popleft` 조합이 일반적

## 수정된 코드

```python
from collections import deque

N, K = map(int, input().split())

dq = deque()
dq.append((N, 0))
visited = set()
visited.add(N)

while dq:
    x, step = dq.popleft()
    
    if x == K:
        print(step)
        break
    
    for nx in (x - 1, x + 1, x * 2):
        if 0 <= nx <= 100000 and nx not in visited:
            visited.add(nx)
            dq.append((nx, step + 1))
```

### 개선 사항 요약
- 정방향 탐색 (N → K)으로 변경
- `append` + `popleft` 사용 (BFS 관례)
- 범위 제한 추가 (`0 <= nx <= 100000`)
- 큐에 넣을 때 visited 체크 (중복 삽입 방지)
- 불필요한 변수 제거
