## 느낀점
>- 랜선 자르기(1654) 와 완전 같은 유형
>- 다음번엔 안 틀릴 것 같은 자신감이 생긴다.

---

## 흐름
1. 절단기 높이를 이분탐색으로 결정
2. 탐색 범위: 0 ~ 가장 높은 나무
3. mid 높이로 잘랐을 때 얻는 나무 총량 계산
4. M 이상이면 높이를 높여보고(left = mid + 1), 미만이면 낮춤(right = mid - 1)
5. 조건 만족하는 최대 높이 출력

## 코드
```python
"""
4 7
20 15 10 17

크면 값이 작아짐

"""

import sys

input = sys.stdin.readline

N, M = map(int, input().split())
woods = list(map(int, input().split()))
woods.sort()
left = 0
right = woods[-1]
result = []

while(left <= right):
    mid = int((left + right) / 2)
    n = 0
    for wood in woods:
        if(mid >= wood): continue
        else:
            n += wood - mid
    # 길이 부족 -> 더 짧게 짤라야 함
    if(n < M):
        right = mid - 1
    # 길이 가능
    elif(n >= M):
        result.append(mid)
        left = mid + 1
print(max(result))
```

---

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| - | - |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|-----------|
| `n == M`일 때만 result 갱신 | `n >= M`일 때 갱신 ("적어도 M미터" 조건) |

---

## AI 코드 리뷰

### 개선할 점

1. **result 리스트 불필요**: 조건 만족할 때마다 리스트에 추가 후 `max()` → 단일 변수로 갱신하면 충분
2. **정수 나눗셈**: `int((left + right) / 2)` → `(left + right) // 2`가 더 명확하고 빠름
3. **변수명**: `n`보다는 `total` 또는 `cut_sum`이 의미 전달에 좋음

## 수정된 코드

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
woods = list(map(int, input().split()))
woods.sort()

left = 0
right = woods[-1]
result = 0

while left <= right:
    mid = (left + right) // 2
    total = 0
    
    for wood in woods:
        if mid < wood:
            total += wood - mid
    
    if total >= M:
        result = mid
        left = mid + 1
    else:
        right = mid - 1

print(result)
```
