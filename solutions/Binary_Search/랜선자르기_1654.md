## 느낀점
>
- 새로운 유형이라 못 풀음 
- 사용하는 개념 배운 후 코드 작성
- 유형 공부하자.

## 흐름

### 1. 문제 변환 (파라메트릭 서치)

**원래 문제:** "N개 이상 만들 수 있는 최대 길이는?"

**변환된 문제:** "길이 X로 자르면 N개 이상 만들 수 있는가?" (Yes/No)

### 2. 탐색 범위 설정

- `left = 1`: 최소 길이 (0이면 나누기 오류)
- `right = 802`: 가장 긴 랜선 (이보다 길게는 못 자름)

### 3. 이분탐색 진행 (예제로 따라가기)

```
랜선: [802, 743, 457, 539], 필요 개수: 11개

[1단계] left=1, right=802
        mid = 401
        개수 = 802//401 + 743//401 + 457//401 + 539//401
             = 2 + 1 + 1 + 1 = 5개
        5 < 11 → 너무 길다! → right = 400

[2단계] left=1, right=400
        mid = 200
        개수 = 4 + 3 + 2 + 2 = 11개
        11 >= 11 → 가능! answer에 200 저장 → left = 201

[3단계] left=201, right=400
        mid = 300
        개수 = 2 + 2 + 1 + 1 = 6개
        6 < 11 → 너무 길다! → right = 299

[4단계] left=201, right=299
        mid = 250
        개수 = 3 + 2 + 1 + 2 = 8개
        8 < 11 → 너무 길다! → right = 249

[5단계] left=201, right=249
        mid = 225
        개수 = 3 + 3 + 2 + 2 = 10개
        10 < 11 → 너무 길다! → right = 224

[6단계] left=201, right=224
        mid = 212
        개수 = 3 + 3 + 2 + 2 = 10개
        10 < 11 → right = 211

[7단계] left=201, right=211
        mid = 206
        개수 = 3 + 3 + 2 + 2 = 10개
        10 < 11 → right = 205

[8단계] left=201, right=205
        mid = 203
        개수 = 3 + 3 + 2 + 2 = 10개
        10 < 11 → right = 202

[9단계] left=201, right=202
        mid = 201
        개수 = 3 + 3 + 2 + 2 = 10개
        10 < 11 → right = 200

[10단계] left=201, right=200
         left > right → 종료!

answer = [200] → 최댓값 = 200
```

### 4. 핵심 원리

```
길이:  ... 198  199  200  201  202 ...
개수:  ... 12   11   11   10   10  ...
가능:  ...  ✓    ✓    ✓    ✗    ✗  ...
                     ↑
                 최댓값(200)
```

- 조건 만족(✓)하면 → 정답 후보 저장 + **오른쪽(더 큰 값)** 탐색
- 조건 불만족(✗)하면 → **왼쪽(더 작은 값)** 탐색
- 결국 ✓와 ✗의 **경계**에서 마지막 ✓를 찾게 됨

## 코드

```python
import sys
input = sys.stdin.readline
N, K = map(int, input().split())
lines = []
for _ in range(N):
    lines.append(int(input()))
left = 1
right = max(lines)
mid = 0
answer = []
while(left <= right):
    mid = int((right + left) / 2)
    count = 0
    for line in lines:
        count += line // mid
    if(count >= K):
        answer.append(mid)
        left = mid + 1
    if(count < K):
        right = mid - 1
print(max(answer))
```

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 1부터 순차탐색하면 안 되나? | 길이 최대 2³¹-1이라 시간 초과. 이분탐색으로 O(log N) |
| 파라메트릭 서치란? | "최댓값 구하라" → "X일 때 가능한가?"로 변환하는 기법 |
| while에서 `<=` vs `<`? | 값 찾기는 `<=`, 경계 찾기(lower bound)는 `<` |
| 정답 후보는 `==`일 때 아니야? | 조건 만족하는 값이 여러 개일 수 있어서 `>=`로 범위 체크 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|--------|----------|
| `left = 0` | `left = 1` (0으로 나누기 오류 방지) |
| 조건 만족 시 `right = mid - 1` | `left = mid + 1` (최댓값 찾으려면 오른쪽 탐색) |
| 정답 후보 저장 안 함 | 조건 만족할 때마다 `answer`에 저장 |

## AI 코드 리뷰

### 개선할 점

1. **리스트 대신 변수 사용**: `answer` 리스트에 append 후 `max()` 하는 대신, 단일 변수로 갱신하면 더 효율적

2. **나눗셈 연산자**: `int((right + left) / 2)` 대신 `(left + right) // 2`가 파이썬스러움

3. **입력 변수명 혼동**: 문제에서 K는 랜선 개수, N은 필요 개수인데 코드에서 뒤바뀜 (동작엔 문제없으나 가독성 저하)

4. **조건문 구조**: 두 `if`문은 상호 배타적이므로 `elif` 사용이 명확

5. **리스트 컴프리헨션**: `lines` 입력을 한 줄로 간결하게 작성 가능

## 수정된 코드

```python
import sys
input = sys.stdin.readline

K, N = map(int, input().split())  # K: 보유 개수, N: 필요 개수
lines = [int(input()) for _ in range(K)]

left = 1
right = max(lines)
answer = 0

while left <= right:
    mid = (left + right) // 2
    count = sum(line // mid for line in lines)
    
    if count >= N:
        answer = mid
        left = mid + 1
    else:
        right = mid - 1

print(answer)
```