## 느낀점
>
- 규칙찾기 -> dp
- 감이 안 잡혀서 힌트 참고했다.


## 흐름

1. **패턴 분석**: N에 따른 0과 1 호출 횟수를 직접 계산
   - N=0: (1, 0), N=1: (0, 1), N=2: (1, 1), N=3: (1, 2)...
2. **규칙 발견**: 
   - 0 개수 = 전 단계의 1 개수
   - 1 개수 = 전 단계의 0 개수 + 1 개수
3. **점화식 도출**: 피보나치 수열과 동일한 패턴
4. **반복문으로 구현**: N=0, 1은 기저 조건으로 처리, 나머지는 반복 계산

## 코드

```python
T = int(input())
for _ in range(T):
    N = int(input())
    if(N == 0):
        print("1 0")
    elif(N == 1):
        print("0 1")
    else:
        i = 2
        prev_0 = 0
        prev_1 = 1
        while True:
            cur_0 = prev_1
            cur_1 = prev_0 + prev_1
            if(i == N):
                print("%d %d" % (cur_0, cur_1))
                break
            i += 1
            prev_0 = cur_0
            prev_1 = cur_1
```

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 단순 재귀는 시간초과일 것 같은데 감이 안 잡혀 | 패턴/규칙 찾기로 접근 - 손으로 몇 개 계산해보면 점화식 발견 가능 |
| 원리를 모르겠어. 규칙찾기로 풀었는데 이래도 될까? | DP의 핵심 접근법. fibonacci(n) 호출 시 내부에서 fibonacci(n-1) + fibonacci(n-2) 호출하므로 0/1 호출 횟수도 동일한 점화식을 따름 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|-----------|
| (없음) | - |

## AI 코드 리뷰

### 개선할 점

1. **출력 포맷팅**: `%` 포맷팅 대신 f-string 사용 권장 (가독성, 현대적 스타일)

2. **반복 구조 단순화**: `while True` + `break` 대신 `for` 문으로 더 명확하게 표현 가능

3. **변수명 개선**: `prev_0`, `prev_1` → `zero`, `one`으로 의미 명확화

4. **DP 테이블 활용**: 테스트 케이스가 여러 개이므로, 미리 N=40까지 계산해두면 중복 계산 방지

## 수정된 코드

```python
import sys
input = sys.stdin.readline

# 미리 N=40까지 계산 (테스트 케이스 중복 계산 방지)
MAX = 41
dp = [(0, 0)] * MAX
dp[0] = (1, 0)  # (0 호출 횟수, 1 호출 횟수)
dp[1] = (0, 1)

for i in range(2, MAX):
    dp[i] = (dp[i-1][0] + dp[i-2][0], dp[i-1][1] + dp[i-2][1])

T = int(input())
for _ in range(T):
    N = int(input())
    print(f"{dp[N][0]} {dp[N][1]}")
```

### 개선 사항 요약

- 전처리로 O(40) 한 번만 계산, 각 쿼리는 O(1)
- f-string으로 출력 간결화
- dp 테이블로 명확한 DP 구조 표현
