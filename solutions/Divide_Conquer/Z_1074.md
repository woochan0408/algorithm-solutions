## 느낀점
>
- (사용자 작성 영역)

---

## 실패한 코드 흐름

1. **완전탐색 접근**: Z 순서대로 모든 칸을 하나씩 방문
2. **기저조건**: length가 2가 되면 4칸을 순회하며 타겟 확인

## 실패한 코드

```python
import sys
from collections import defaultdict
input = sys.stdin.readline
N, R, C = map(int, input().split())
maxLen = 2**N
result = 0
founded = False
def solve(r, c, length):
    global result
    global founded
    
    if(founded):
        return
    if(length == 2):
        arr = ((r, c), (r, c+1), (r+1, c), (r+1, c+1))
        for dr, dc in arr:
            result += 1
            if(dr == R and dc == C):
                founded = True
                return
            else:
                return
        
    else:
        length = int(length / 2)
        solve(r, c, length)
        solve(r, c+length, length)
        solve(r+length, c, length)
        solve(r+length, c+length, length)
        return
solve(0, 0, maxLen)
print(result)
```

**문제점**: N=15일 때 최대 2^30(약 10억) 칸 탐색 → 시간초과

---

## 성공한 코드 흐름

1. **분할정복 + 가지치기**: 4개 사분면 중 타겟이 속한 사분면만 탐색
2. **스킵 계산**: 타겟이 없는 사분면은 방문하지 않고, 해당 사분면 크기(length²)만큼 result에 더함
3. **기저조건**: length가 2가 되면 4칸 중 타겟 위치까지의 순서 계산
4. **시간복잡도**: O(N) - 매 단계 4분할 중 1개만 탐색, 총 N번 분할

## 성공한 코드

```python
import sys
from collections import defaultdict
input = sys.stdin.readline
N, R, C = map(int, input().split())
maxLen = 2**N
result = 0
founded = False
def solve(r, c, length):
    global result
    global founded
    
    if(founded):
        return
    if(length == 2):
        arr = ((r, c), (r, c+1), (r+1, c), (r+1, c+1))
        for dr, dc in arr:
            if(dr == R and dc == C):
                founded = True
                return
            else:
                result += 1
                continue
        
    else:
        length = int(length / 2)
        plus = length*length
        if(R < length+r):
            if(C < length + c):
                solve(r, c, length)
            else:
                result += plus
                solve(r, c+length, length)
        else:
            if(C < length + c):
                result += plus*2
                solve(r+length, c, length)
            else:
                result += plus*3
                solve(r+length, c+length, length)
        return
solve(0, 0, maxLen)
print(result)
```

---

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 재귀로 푸니까 시간초과 | 타겟이 포함되지 않은 사분면은 탐색하지 않고 크기만 더해서 스킵 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|-----------|
| 모든 사분면을 재귀 탐색 (완전탐색) | 타겟이 속한 사분면만 탐색 (가지치기) |
| for문 안에서 `return` (첫 번째 칸만 처리 후 종료) | `continue`로 다음 칸 계속 탐색 |

---

## AI 코드 리뷰

### 개선할 점

1. **변수명 오타**: `founded` → `found` (found의 과거형은 found)

2. **불필요한 import 제거**: `defaultdict` 사용하지 않음

3. **정수 나눗셈**: `int(length / 2)` → `length // 2`가 더 명확하고 빠름

4. **global 제거 가능**: 반환값을 활용하면 global 변수 없이 구현 가능

5. **기저조건 단순화**: `length == 2` 대신 `length == 1`로 하면 4칸 순회 로직 불필요

## 수정된 코드

```python
import sys
input = sys.stdin.readline

N, R, C = map(int, input().split())

def solve(r, c, length):
    if length == 1:
        return 0
    
    half = length // 2
    area = half * half
    
    # 1사분면 (좌상)
    if R < r + half and C < c + half:
        return solve(r, c, half)
    # 2사분면 (우상)
    elif R < r + half and C >= c + half:
        return area + solve(r, c + half, half)
    # 3사분면 (좌하)
    elif R >= r + half and C < c + half:
        return area * 2 + solve(r + half, c, half)
    # 4사분면 (우하)
    else:
        return area * 3 + solve(r + half, c + half, half)

print(solve(0, 0, 2 ** N))
```

### 개선 사항 요약

- global 변수 제거 → 반환값으로 누적
- 기저조건 `length == 1` → 더 이상 분할 불가 시 0 반환
- 사분면 판별 로직을 elif로 명확하게 분리
- 불필요한 import, 변수 제거
