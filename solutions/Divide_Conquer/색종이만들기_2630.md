## 느낀점
>
- 오랜만에 원큐에 푼 문제였다.
- 기쁘다
- return , break 잘못써서 삽질 한 번

## 흐름

1. **초기 진입**: 전체 종이 크기()에서 탐색을 시작합니다.
2. **색상 검사**: 현재 영역의 왼쪽 상단 색상을 기준으로, 영역 내 모든 칸이 같은 색인지 순회하며 확인합니다.
3. **분할 (재귀)**: 순회 중 다른 색상이 발견되면, 즉시 중단하고 영역을 4등분()하여 각 사분면에 대해 재귀적으로 함수를 호출합니다.
4. **결과 합산**: 영역 내 모든 색상이 같으면 해당 색상(0: 하얀색, 1: 파란색)의 카운트를 1 증가시키고 재귀를 종료합니다.

## 코드

```python
import sys
input = sys.stdin.readline

def validate(startX, startY, length):
    global whiteResult
    global blueResult
    default = grid[startX][startY]
    for i in range(startX, startX+length):
        for j in range(startY, startY+length):
            if(grid[i][j] != default):
                length = int(length/2)
                validate(startX, startY, length)
                validate(startX+length, startY, length)
                validate(startX, startY+length, length)
                validate(startX+length, startY+length, length)
                return
    if(default == 0):
        whiteResult += 1
    else:
        blueResult += 1

whiteResult = 0
blueResult = 0
N = int(input())
grid = []
for i in range(N):
    grid.append(list(map(int, input().split())))

validate(0, 0, N)
print(whiteResult)
print(blueResult)

```

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
| --- | --- |
| 없음 | 직접 풀이를 완료하여 질문 과정이 없었습니다. |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
| --- | --- |
| 없음 | 논리적으로 완결된 코드를 작성하였습니다. |

---

## AI 코드 리뷰

### 개선할 점

1. **정수 나눗셈 연산자 활용**: `int(length/2)` 대신 파이썬의 정수 나눗셈 연산자인 `//`를 사용하면 더 간결합니다. `length // 2`와 같이 작성할 수 있습니다.
2. **함수 네이밍**: `validate`는 보통 '유효성 검사'의 의미로 쓰입니다. 종이를 분할하고 개수를 세는 로직이므로 `count_paper`나 `solve` 같은 이름이 더 직관적입니다.
3. **전역 변수(`global`) 사용 지양**: 현재 코드도 정답 처리는 되지만, 대규모 프로젝트나 복잡한 로직에서는 `global` 변수가 코드 추적을 어렵게 만듭니다. 재귀 함수의 반환값으로 (하얀색 개수, 파란색 개수) 튜플을 넘겨주는 방식이 더 깔끔합니다.

### 더 나은 로직 설명

현재의 2중 for문을 통한 색상 확인 방식()은 충분히 효율적입니다. 여기서 가독성을 높이기 위해 **분할 정복의 결과값을 반환**하는 형태로 구조를 개선하면, 함수가 독립적으로 동작하게 되어 유지보수가 쉬워집니다.

## 수정된 코드

```python
import sys
input = sys.stdin.readline

def count_paper(r, c, n, grid):
    """
    (r, c): 시작 행, 열 위치
    n: 현재 정사각형의 한 변의 길이
    반환값: (white_count, blue_count)
    """
    first_color = grid[r][c]
    
    for i in range(r, r + n):
        for j in range(c, c + n):
            if grid[i][j] != first_color:
                # 색상이 다르면 4등분하여 재귀 호출
                half = n // 2
                w1, b1 = count_paper(r, c, half, grid)              # 1사분면 (좌상)
                w2, b2 = count_paper(r, c + half, half, grid)       # 2사분면 (우상)
                w3, b3 = count_paper(r + half, c, half, grid)       # 3사분면 (좌하)
                w4, b4 = count_paper(r + half, c + half, half, grid) # 4사분면 (우하)
                
                return w1 + w2 + w3 + w4, b1 + b2 + b3 + b4
    
    # 모든 칸의 색상이 같으면 해당 색상 카운트 반환
    if first_color == 0:
        return 1, 0
    else:
        return 0, 1

def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    white_total, blue_total = count_paper(0, 0, n, grid)
    
    print(white_total)
    print(blue_total)

if __name__ == "__main__":
    solve()

```