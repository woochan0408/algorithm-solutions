## 느낀점
>
- 단순히 생각했다가 시간초과
- 구간합 로직 잘 정리해두자

---

## 실패한 코드 흐름
1. 매 쿼리마다 `sum(arr[start:end+1])` 계산
2. M개 쿼리 × N개 원소 = O(N × M) = 최대 100억 연산 → 시간초과

## 실패한 코드

```python
import sys
input = sys.stdin.readline
N, M = map(int, input().split())
arr = tuple(map(int, input().split()))
for _ in range(M):
    start, end = map(int, input().split())
    start -= 1
    end -= 1
    print(sum(arr[i] for i in range(start, end+1)))
```

**문제점**: 쿼리마다 O(N) 연산 → 총 O(N × M) 시간초과

---

## 성공한 코드 흐름

1. 누적합 배열 한 번 생성: O(N)
2. 각 쿼리는 `prefix[end] - prefix[start-1]`로 O(1) 처리
3. 총 시간복잡도: O(N + M)

## 성공한 코드

```python
import sys
input = sys.stdin.readline
N, M = map(int, input().split())
arr = tuple(map(int, input().split()))
nuArr = []
nuHap = 0
for i in arr:
    nuHap += i
    nuArr.append(nuHap)
for _ in range(M):
    start, end = map(int, input().split())
    nuHapLast = nuArr[end-1]
    nuHapFirst = 0 if start-2 < 0 else nuArr[start-2]
    print(nuHapLast - nuHapFirst)
```

---

## 질문 & 실수 정리

### 질문했던 내용 (새로 배운 것)

| 질문 | 답변 |
|------|------|
| 시간초과 해결법 | 누적합(Prefix Sum) 전처리로 각 쿼리 O(1) 처리 |

### 실수했던 부분

| 틀린 것 | 올바른 것 |
|---------|-----------|
| 매 쿼리마다 sum() 호출 O(N×M) | 누적합 전처리 후 O(1) 조회 |

---

## AI 코드 리뷰

### 개선할 점

1. **변수명 개선**: `nuArr`, `nuHap` → `prefix`, `total` 등 영어 단어로 통일하면 가독성 향상

2. **인덱스 처리 단순화**: 누적합 배열 맨 앞에 0을 추가하면 `start-2 < 0` 조건문 불필요

3. **불필요한 변수 제거**: `nuHapLast`, `nuHapFirst` 중간 변수 없이 바로 출력 가능

### 수정된 코드

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
arr = list(map(int, input().split()))

# prefix[i] = arr[0] ~ arr[i-1]의 합
# prefix[0] = 0으로 시작하면 인덱스 처리가 깔끔
prefix = [0]
for num in arr:
    prefix.append(prefix[-1] + num)

for _ in range(M):
    i, j = map(int, input().split())
    print(prefix[j] - prefix[i - 1])
```

### 개선 사항 요약

- `prefix[0] = 0` 추가 → 경계 조건 체크 제거
- 1-indexed 입력을 그대로 활용 (변환 불필요)
- 중간 변수 제거로 코드 간결화
